const config = require('../config')
const { cmd, commands } = require('../command')
var os = require('os')
const dl = require('@bochilteam/scraper')  
const ytdl = require('youtubedl-core');
const api = require("caliph-api");
const fs = require('fs-extra')


cmd({
    pattern: "yt",
    use: '.yt lelena',
    react: "üìΩÔ∏è",
    desc: descyt,
    category: "download",
    filename: __filename

},

async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
if (!q) return await reply(imgmsg)
if(isUrl(q) && !ytreg(q)) return await reply(imgmsg)
if(isUrl(q) && q.includes('/shorts')){let dat = `‚îå‚îÄ‚îÄ‚îÄ[üßö Ôº±ÔºµÔº•Ôº•ÔºÆ -Ôº©Ôº∫ÔºµÔº≠Ôº© - Ôº≠Ôº§ üßö]

  *SELECT TYPE*`

const sections = [
    {
	title: "",
	rows: [
	    {title: "1", rowId: prefix + 'selectaud ' + q , description: 'SONG'},
	    {title: "2", rowId: prefix + 'selectvid ' + q , description: 'VIDEO'} ,

	]
    } 
]
const listMessage = {
  text: dat,
  footer: config.FOOTER,
  buttonText: "üî¢ Reply below number,",
  sections,
  contextInfo: {
				
				externalAdReply: { 
					title: 'üßö Ôº±ÔºµÔº•Ôº•ÔºÆ -Ôº©Ôº∫ÔºµÔº≠Ôº© - Ôº≠Ôº§ üßö',
					body: '·¥Ä…¥ ·¥úÍú±·¥á Ä  ô·¥è·¥õ Íú∞·¥è Ä ·¥° ú·¥Ä·¥õÍú±·¥Ä·¥ò·¥ò',
					mediaType: 1,
					sourceUrl: "" ,
          thumbnailUrl: 'https://telegra.ph/file/ba8ea739e63bf28c30b37.jpg' ,
					renderLargerThumbnail: false,
          showAdAttribution: true
         }}	
}

return await conn.replyList(from, listMessage ,{ quoted : mek })				      
}
if(ytreg(q)){let dat = `[üßö Ôº±ÔºµÔº•Ôº•ÔºÆ -Ôº©Ôº∫ÔºµÔº≠Ôº© - Ôº≠Ôº§ üßö]

*SELECT SONG TYPE*`
const sections = [
    {
	title: "",
	rows: [
	    {title: "1", rowId: prefix + 'ytdocs ' + q , description: 'DOCUMENT SONG'},
	    {title: "2", rowId: prefix + 'ytmp3 '  + q , description: 'AUDIO SONG'} ,

	]
    } 
]
const listMessage = {
  text: dat,
  footer: config.FOOTER,
  buttonText: "üî¢ Reply below number,",
  sections }	

	     
return await conn.replyList(from, listMessage ,{ quoted : mek })

}
let yts = require("yt-search")
let search = await yts(q)
let anu = search.videos[0]
const cap = `[üßö Ôº±ÔºµÔº•Ôº•ÔºÆ -Ôº©Ôº∫ÔºµÔº≠Ôº© - Ôº≠Ôº§ üßö]

   *YT DOWNLOADER*

‚ïèüéÄ *Title:* ${anu.title}
‚¶Å
‚ïèüåê *Duration:* ${anu.timestamp}
‚¶Å
‚ïèüëÄ *Viewers:* ${anu.views}
‚¶Å
‚ïè‚¨ÜÔ∏è *Uploaded:* ${anu.ago}
‚¶Å
‚ïèüëΩ *Author:* ${anu.author.name}
‚¶Å
‚ïèüì° *Url* : ${anu.url}`

const sections = [
    {
	title: "",
	rows: [
	    {title: "1", rowId: prefix + 'selectaud ' + anu.url , description: 'SONG'},
	    {title: "2", rowId: prefix + 'selectvid ' + anu.url , description: 'VIDEO'} ,

	]
    } 
]
const listMessage = {
  image: {url: anu.thumbnail},
  caption: cap,
  footer: config.FOOTER,
  buttonText: "üî¢ Reply below number,",
  sections,
  contextInfo: {
				
				externalAdReply: { 
					title: 'üßö Ôº±ÔºµÔº•Ôº•ÔºÆ -Ôº©Ôº∫ÔºµÔº≠Ôº© - Ôº≠Ôº§ üßö',
					body: '·¥Ä…¥ ·¥úÍú±·¥á Ä  ô·¥è·¥õ Íú∞·¥è Ä ·¥° ú·¥Ä·¥õÍú±·¥Ä·¥ò·¥ò',
					mediaType: 1,
					sourceUrl: "" ,
          thumbnailUrl: 'https://telegra.ph/file/ba8ea739e63bf28c30b37.jpg' ,
					renderLargerThumbnail: false,
          showAdAttribution: true
         }}	
}

await conn.replyList(from, listMessage ,{ quoted : mek }) 

} catch (e) {
  reply(N_FOUND)
  l(e)
}
})

//---------------------------------------------------------------------------

cmd({
    pattern: "video",
    alias: ["ytvideo"],
    use: '.video lelena',
    react: "üìΩÔ∏è",
    desc: descv,
    category: "download",
    filename: __filename

},

async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
if (!q) return await reply(imgmsg)
if(isUrl(q) && !ytreg(q)) return await reply(imgmsg)
if(isUrl(q) && q.includes('/shorts')){let dat = `‚îå‚îÄ‚îÄ‚îÄ[üßö Ôº±ÔºµÔº•Ôº•ÔºÆ -Ôº©Ôº∫ÔºµÔº≠Ôº© - Ôº≠Ôº§ üßö]

  *SELECT TYPE*`

const sections = [
    {
	title: "",
	rows: [
	   {title: "1", rowId: prefix + '240p ' + q , description: '240p Quality Video'},
	   {title: "2", rowId: prefix + '360p ' + q , description: '360p Quality Video'} ,
           {title: "3", rowId: prefix + '480p ' + q , description: '480p Quality Video'},
	   {title: "4", rowId: prefix + '720p ' + q , description: '720p Quality Video'} ,
           {title: "5", rowId: prefix + '1080p ' + q , description: '1080p Quality Video'},
	   {title: "6", rowId: prefix + '1440p ' + q , description: '1440p Quality Video'} ,
           {title: "7", rowId: prefix + '2160p ' + q , description: '2160p Quality Video'},
	   {title: "8", rowId: prefix + 'ytdocv ' + q , description: 'Document type Video'} ,
	]
    } 
]
const listMessage = {
  text: dat,
  footer: config.FOOTER,
  buttonText: "üî¢ Reply below number,",
  sections,
  contextInfo: {
				
				externalAdReply: { 
					title: 'üßö Ôº±ÔºµÔº•Ôº•ÔºÆ -Ôº©Ôº∫ÔºµÔº≠Ôº© - Ôº≠Ôº§ üßö',
					body: '·¥Ä…¥ ·¥úÍú±·¥á Ä  ô·¥è·¥õ Íú∞·¥è Ä ·¥° ú·¥Ä·¥õÍú±·¥Ä·¥ò·¥ò',
					mediaType: 1,
					sourceUrl: "" ,
          thumbnailUrl: 'https://telegra.ph/file/ba8ea739e63bf28c30b37.jpg' ,
					renderLargerThumbnail: false,
          showAdAttribution: true
         }}	
}

return await conn.replyList(from, listMessage ,{ quoted : mek }) 				      
}
if(ytreg(q)){let dat = `[üßö Ôº±ÔºµÔº•Ôº•ÔºÆ -Ôº©Ôº∫ÔºµÔº≠Ôº© - Ôº≠Ôº§ üßö]

*SELECT SONG TYPE*`
const sections = [
    {
	title: "",
	rows: [
	   {title: "1", rowId: prefix + '240p ' + q , description: '240p Quality Video'},
	   {title: "2", rowId: prefix + '360p ' + q , description: '360p Quality Video'} ,
           {title: "3", rowId: prefix + '480p ' + q , description: '480p Quality Video'},
	   {title: "4", rowId: prefix + '720p ' + q , description: '720p Quality Video'} ,
           {title: "5", rowId: prefix + '1080p ' + q , description: '1080p Quality Video'},
	   {title: "6", rowId: prefix + '1440p ' + q , description: '1440p Quality Video'} ,
           {title: "7", rowId: prefix + '2160p' + q , description: '2160p Quality Video'},
	   {title: "8", rowId: prefix + 'ytdocv ' + q , description: 'Document type Video'} ,

	]
    } 
]
const listMessage = {
  text: dat,
  footer: config.FOOTER,
  buttonText: "üî¢ Reply below number,",
  sections }	

	     
return await conn.replyList(from, listMessage ,{ quoted : mek }) 

}
let yts = require("yt-search")
let search = await yts(q)
let anu = search.videos[0]
const cap = `[üßö Ôº±ÔºµÔº•Ôº•ÔºÆ -Ôº©Ôº∫ÔºµÔº≠Ôº© - Ôº≠Ôº§ üßö]

   *YT DOWNLOADER*

‚ïèüéÄ *Title:* ${anu.title}
‚¶Å
‚ïèüåê *Duration:* ${anu.timestamp}
‚¶Å
‚ïèüëÄ *Viewers:* ${anu.views}
‚¶Å
‚ïè‚¨ÜÔ∏è *Uploaded:* ${anu.ago}
‚¶Å
‚ïèüëΩ *Author:* ${anu.author.name}
‚¶Å
‚ïèüì° *Url* : ${anu.url}`

const sections = [
    {
	title: "",
	rows: [
	   {title: "1", rowId: prefix + '240p ' + anu.url , description: '240p Quality Video'},
	   {title: "2", rowId: prefix + '360p ' + anu.url , description: '360p Quality Video'} ,
           {title: "3", rowId: prefix + '480p ' + anu.url , description: '480p Quality Video'},
	   {title: "4", rowId: prefix + '720p ' + anu.url , description: '720p Quality Video'} ,
           {title: "5", rowId: prefix + '1080p ' + anu.url , description: '1080p Quality Video'},
	   {title: "6", rowId: prefix + '1440p ' + anu.url , description: '1440p Quality Video'} ,
           {title: "7", rowId: prefix + '2160p ' + anu.url , description: '2160p Quality Video'},
	   {title: "8", rowId: prefix + 'ytdocv ' + anu.url , description: 'Document type Video'} ,
	]
    } 
]
const listMessage = {
  image: {url: anu.thumbnail},
  caption: cap,
  footer: config.FOOTER,
  buttonText: "üî¢ Reply below number,",
  sections,
  contextInfo: {
				
				externalAdReply: { 
					title: 'üßö Ôº±ÔºµÔº•Ôº•ÔºÆ -Ôº©Ôº∫ÔºµÔº≠Ôº© - Ôº≠Ôº§ üßö',
					body: '·¥Ä…¥ ·¥úÍú±·¥á Ä  ô·¥è·¥õ Íú∞·¥è Ä ·¥° ú·¥Ä·¥õÍú±·¥Ä·¥ò·¥ò',
					mediaType: 1,
					sourceUrl: "" ,
          thumbnailUrl: 'https://telegra.ph/file/ba8ea739e63bf28c30b37.jpg' ,
					renderLargerThumbnail: false,
          showAdAttribution: true
         }}	
}

await conn.replyList(from, listMessage ,{ quoted : mek }) 

} catch (e) {
  reply(N_FOUND)
  l(e)
}
})


//---------------------------------------------------------------------------

cmd({
  pattern: "selectaud",
  alias: ["selectaud"],
  filename: __filename
},
async(conn, mek, m,{from, l, quoted, prefix, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
let dat = `[üßö Ôº±ÔºµÔº•Ôº•ÔºÆ -Ôº©Ôº∫ÔºµÔº≠Ôº© - Ôº≠Ôº§ üßö]

  *SELECT SONG TYPE*`

	 const sections = [
    {
	title: "",
	rows: [
	    {title: "1", rowId: prefix + 'ytdocs ' + q , description: 'Document type Song'},
	    {title: "2", rowId: prefix + 'ytmp3 ' + q , description: 'Audio type Song'} ,
	    {title: "3", rowId: prefix + 'ytinfo ' + q , description: 'To see Song info'} 

	]
    } 
]
	const listMessage = {
 text : dat ,
  footer: config.FOOTER,
  buttonText: "üî¢ Reply below number,",
  sections,
  contextInfo: {
				
				externalAdReply: { 
					title: 'üßö Ôº±ÔºµÔº•Ôº•ÔºÆ -Ôº©Ôº∫ÔºµÔº≠Ôº© - Ôº≠Ôº§ üßö',
					body: '·¥Ä…¥ ·¥úÍú±·¥á Ä  ô·¥è·¥õ Íú∞·¥è Ä ·¥° ú·¥Ä·¥õÍú±·¥Ä·¥ò·¥ò',
					mediaType: 1,
					sourceUrl: "" ,
          thumbnailUrl: 'https://telegra.ph/file/ba8ea739e63bf28c30b37.jpg' ,
					renderLargerThumbnail: false,
          showAdAttribution: true
         }}	
}
 
return await conn.replyList(from, listMessage ,{ quoted : mek }) 
} catch (e) {
reply(N_FOUND)
l(e)
}
})

//---------------------------------------------------------------------------

cmd({
  alias: ["selectvid"],
  filename: __filename
},
async(conn, mek, m,{from, l, quoted, prefix, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
let dat = `[üßö Ôº±ÔºµÔº•Ôº•ÔºÆ -Ôº©Ôº∫ÔºµÔº≠Ôº© - Ôº≠Ôº§ üßö]

  *SELECT SONG TYPE*`

	 const sections = [
    {
	title: "",
	rows: [
	    {title: "1", rowId: prefix + '240p ' + q , description: '240p Quality Video'},
	    {title: "2", rowId: prefix + '360p ' + q , description: '360p Quality Video'},
	    {title: "3", rowId: prefix + '480p ' + q , description: '480p Quality Video'},
	    {title: "4", rowId: prefix + '720p ' + q , description: '720p Quality Video'},
	    {title: "5", rowId: prefix + '1080p ' + q , description: '1080p Quality Video'},
	    {title: "6", rowId: prefix + '1440p ' + q , description: '1440p Quality Video'},
	    {title: "7", rowId: prefix + '2160p ' + q , description: '2160p Quality Video'},
	    {title: "8", rowId: prefix + 'ytdocv ' + q , description: 'Document type Video'}

	]
    } 
]
	const listMessage = {
 text : dat ,
  footer: config.FOOTER,
  buttonText: "üî¢ Reply below number,",
  sections,
  contextInfo: {
				
				externalAdReply: { 
					title: 'üßö Ôº±ÔºµÔº•Ôº•ÔºÆ -Ôº©Ôº∫ÔºµÔº≠Ôº© - Ôº≠Ôº§ üßö',
					body: '·¥Ä…¥ ·¥úÍú±·¥á Ä  ô·¥è·¥õ Íú∞·¥è Ä ·¥° ú·¥Ä·¥õÍú±·¥Ä·¥ò·¥ò',
					mediaType: 1,
					sourceUrl: "" ,
          thumbnailUrl: 'https://telegra.ph/file/ba8ea739e63bf28c30b37.jpg' ,
					renderLargerThumbnail: false,
          showAdAttribution: true
         }}	
}
 
return await conn.replyList(from, listMessage ,{ quoted : mek }) 
} catch (e) {
reply(N_FOUND)
l(e)
}
})


//===================================================================================================

cmd({
  pattern: "240p",
  use: '.240p <video url>',
  react: "üìΩÔ∏è",
  desc: "Download yt videos.",
  category: "",
  filename: __filename

},

async(conn, mek, m,{from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
if (!ytreg(q)) return await  reply(urlneed)
const yt2 = await  dl.youtubedl(q)
let yt = yt2
let size = await getsize(await yt.video['240p'].download())
if (size.includes('MB') && size.replace(' MB','') >= config.MAX_SIZE) return await conn.sendMessage(from, { text: sizetoo }, { quoted: mek });
if (size.includes('GB')) return await conn.sendMessage(from, { text: sizetoo }, { quoted: mek });
let senda = await conn.sendMessage(from, { video: {url: await yt.video['240p'].download() },caption: config.FOOTER}, { quoted: mek })  
await conn.sendMessage(from, { react: { text: 'üé•', key: senda.key }})
} catch (e) {
reply(N_FOUND)
l(e)
}
})

//---------------------------------------------------------------------------

cmd({
  pattern: "360p",
  use: '.360p <video url>',
  react: "üìΩÔ∏è",
  desc: "Download yt videos.",
  category: "",
  filename: __filename

},

async(conn, mek, m,{from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
if (!ytreg(q)) return await  reply(urlneed)
const yt2 = await  dl.youtubedl(q)
let yt = yt2
let size = await getsize(await yt.video['360p'].download())
if (size.includes('MB') && size.replace(' MB','') >= config.MAX_SIZE) return await conn.sendMessage(from, { text: sizetoo }, { quoted: mek });
if (size.includes('GB')) return await conn.sendMessage(from, { text: sizetoo }, { quoted: mek });
let senda = await conn.sendMessage(from, { video: {url: await yt.video['360p'].download() },caption: config.FOOTER}, { quoted: mek })  
await conn.sendMessage(from, { react: { text: 'üé•', key: senda.key }})
} catch (e) {
reply(N_FOUND)
l(e)
}
})

//---------------------------------------------------------------------------

cmd({
  pattern: "480p",
  use: '.480p <video url>',
  react: "üìΩÔ∏è",
  desc: "Download yt videos.",
  category: "",
  filename: __filename

},

async(conn, mek, m,{from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
if (!ytreg(q)) return await  reply(urlneed)
const yt2 = await  dl.youtubedl(q)
let yt = yt2
let size = await getsize(await yt.video['480p'].download())
if (size.includes('MB') && size.replace(' MB','') >= config.MAX_SIZE) return await conn.sendMessage(from, { text: sizetoo }, { quoted: mek });
if (size.includes('GB')) return await conn.sendMessage(from, { text: sizetoo }, { quoted: mek });
let senda = await conn.sendMessage(from, { video: {url: await yt.video['480p'].download() },caption: config.FOOTER}, { quoted: mek })  
await conn.sendMessage(from, { react: { text: 'üé•', key: senda.key }})
} catch (e) {
reply(N_FOUND)
l(e)
}
})

//---------------------------------------------------------------------------

cmd({
    pattern: "720p",
    use: '.720p <video url>',
    react: "üìΩÔ∏è",
    desc: "Download yt videos.",
    category: "",
    filename: __filename

},

async(conn, mek, m,{from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
if (!ytreg(q)) return await  reply(urlneed)
const yt2 = await  dl.youtubedl(q)
let yt = yt2
let size = await getsize(await yt.video['720p'].download())
if (size.includes('MB') && size.replace(' MB','') >= config.MAX_SIZE) return await conn.sendMessage(from, { text: sizetoo }, { quoted: mek });
if (size.includes('GB')) return await conn.sendMessage(from, { text: sizetoo }, { quoted: mek });
let senda = await conn.sendMessage(from, { video: {url: await yt.video['720p'].download() },caption: config.FOOTER}, { quoted: mek })  
await conn.sendMessage(from, { react: { text: 'üé•', key: senda.key }})
} catch (e) {
reply(N_FOUND)
l(e)
}
})

//---------------------------------------------------------------------------

cmd({
  pattern: "1080p",
  use: '.1080p <video url>',
  react: "üìΩÔ∏è",
  desc: "Download yt videos.",
  category: "",
  filename: __filename

},

async(conn, mek, m,{from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
if (!ytreg(q)) return await  reply(urlneed)
const yt2 = await  dl.youtubedl(q)
let yt = yt2
let size = await getsize(await yt.video['1080p'].download())
if (size.includes('MB') && size.replace(' MB','') >= config.MAX_SIZE) return await conn.sendMessage(from, { text: sizetoo }, { quoted: mek });
if (size.includes('GB')) return await conn.sendMessage(from, { text: sizetoo }, { quoted: mek });
let senda = await conn.sendMessage(from, { video: {url: await yt.video['1080p'].download() },caption: config.FOOTER}, { quoted: mek })  
await conn.sendMessage(from, { react: { text: 'üé•', key: senda.key }})
} catch (e) {
reply(N_FOUND)
l(e)
}
})

//---------------------------------------------------------------------------

cmd({
  pattern: "1440p",
  use: '.1440p <video url>',
  react: "üìΩÔ∏è",
  desc: "Download yt videos.",
  category: "",
  filename: __filename

},

async(conn, mek, m,{from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
if (!ytreg(q)) return await  reply(urlneed)
const yt2 = await  dl.youtubedl(q)
let yt = yt2
let size = await getsize(await yt.video['1440p'].download())
if (size.includes('MB') && size.replace(' MB','') >= config.MAX_SIZE) return await conn.sendMessage(from, { text: sizetoo }, { quoted: mek });
if (size.includes('GB')) return await conn.sendMessage(from, { text: sizetoo }, { quoted: mek });
let senda = await conn.sendMessage(from, { video: {url: await yt.video['1440p'].download() },caption: config.FOOTER}, { quoted: mek })  
await conn.sendMessage(from, { react: { text: 'üé•', key: senda.key }})
} catch (e) {
reply(N_FOUND)
l(e)
}
})

//---------------------------------------------------------------------------

cmd({
  pattern: "2160p",
  use: '.2160p <video url>',
  react: "üìΩÔ∏è",
  desc: "Download yt videos.",
  category: "",
  filename: __filename

},

async(conn, mek, m,{from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
if (!ytreg(q)) return await  reply(urlneed)
const yt2 = await  dl.youtubedl(q)
let yt = yt2
let size = await getsize(await yt.video['2160p'].download())
if (size.includes('MB') && size.replace(' MB','') >= config.MAX_SIZE) return await conn.sendMessage(from, { text: sizetoo }, { quoted: mek });
if (size.includes('GB')) return await conn.sendMessage(from, { text: sizetoo }, { quoted: mek });
let senda = await conn.sendMessage(from, { video: {url: await yt.video['2160p'].download() },caption: config.FOOTER}, { quoted: mek })  
await conn.sendMessage(from, { react: { text: 'üé•', key: senda.key }})
} catch (e) {
reply(N_FOUND)
l(e)
}
})

//---------------------------------------------------------------------------

cmd({
  pattern: "ytmp3",
  use: '.ytmp3 <yt url>',
  react: "üéß",
  desc: "Download yt song.",
  category: "download",
  filename: __filename
},

async(conn, mek, m,{from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
if (!ytreg(q)) return await  reply(urlneed)
let infoYt = await ytdl.getInfo(q);
if (infoYt.videoDetails.lengthSeconds >= videotime) {
  reply(sizetoo);
  return;
}
let titleYt = infoYt.videoDetails.title;
let randomName = getRandom(".mp3");
const stream = ytdl(q, {
      filter: (info) => info.audioBitrate == 160 || info.audioBitrate == 128,
  })
  .pipe(fs.createWriteStream(`./${randomName}`));
await new Promise((resolve, reject) => {
  stream.on("error", reject);
  stream.on("finish", resolve);
});

let stats = fs.statSync(`./${randomName}`);
let fileSizeInBytes = stats.size;
let fileSizeInMegabytes = fileSizeInBytes / (1024 * 1024);
if (fileSizeInMegabytes <= config.MAX_SIZE) {
let sendaE =  await conn.sendMessage(from, { audio: fs.readFileSync(`./${randomName}`), mimetype: 'audio/mpeg', fileName:  `${titleYt}.mp3` }, { quoted: mek })
await conn.sendMessage(from, { react: { text: 'üéº', key: sendaE.key }})
return fs.unlinkSync(`./${randomName}`);
} else {
reply(sizetoo)
}
fs.unlinkSync(`./${randomName}`);
} catch (e) {
reply(N_FOUND)
l(e)
}
})

//---------------------------------------------------------------------------

cmd({
  pattern: "ytmp4",
  use: '.ytmp3 <yt url>',
  react: "üéß",
  desc: "Download yt song.",
  category: "download",
  filename: __filename
},

async(conn, mek, m,{from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
if (!ytreg(q)) return await  reply(urlneed)
let infoYt = await ytdl.getInfo(q);
if (infoYt.videoDetails.lengthSeconds >= videotime) {
  reply(sizetoo);
  return;
}
let titleYt = infoYt.videoDetails.title;
let randomName = getRandom(".mp3");
const stream = ytdl(q, {
      filter: (info) => info.audioBitrate == 160 || info.audioBitrate == 128,
  })
  .pipe(fs.createWriteStream(`./${randomName}`));
await new Promise((resolve, reject) => {
  stream.on("error", reject);
  stream.on("finish", resolve);
});

let stats = fs.statSync(`./${randomName}`);
let fileSizeInBytes = stats.size;
let fileSizeInMegabytes = fileSizeInBytes / (1024 * 1024);
if (fileSizeInMegabytes <= config.MAX_SIZE) {
let sendaE =  await conn.sendMessage(from, { video: fs.readFileSync(`./${randomName}`), mimetype: 'video/mp4', fileName:  `${titleYt}.mp3` }, { quoted: mek })
await conn.sendMessage(from, { react: { text: 'üéº', key: sendaE.key }})
return fs.unlinkSync(`./${randomName}`);
} else {
reply(sizetoo)
}
fs.unlinkSync(`./${randomName}`);
} catch (e) {
reply(N_FOUND)
l(e)
}
})

//---------------------------------------------------------------------------

cmd({
  pattern: "ytdocs",
  use: '.ytdoc <yt url>',
  react: "üéß",
  desc: "Download yt song.",
  category: "download",
  filename: __filename
},

async(conn, mek, m,{from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
if (!ytreg(q)) return await  reply(urlneed)
let infoYt = await ytdl.getInfo(q);
if (infoYt.videoDetails.lengthSeconds >= videotime) {
  reply(sizetoo);
  return;
}
let titleYt = infoYt.videoDetails.title;
let randomName = getRandom(".mp3");
const stream = ytdl(q, {
      filter: (info) => info.audioBitrate == 160 || info.audioBitrate == 128,
  })
  .pipe(fs.createWriteStream(`./${randomName}`));
await new Promise((resolve, reject) => {
  stream.on("error", reject);
  stream.on("finish", resolve);
});

let stats = fs.statSync(`./${randomName}`);
let fileSizeInBytes = stats.size;
let fileSizeInMegabytes = fileSizeInBytes / (1024 * 1024);
if (fileSizeInMegabytes <= config.MAX_SIZE) {
  let senda =  await conn.sendMessage(from, { document: fs.readFileSync(`./${randomName}`), mimetype: 'audio/mpeg', fileName: titleYt + '.mp3',caption: config.FOOTER  }, { quoted: mek })
  await conn.sendMessage(from, { react: { text: 'üéº', key: senda.key }})
return fs.unlinkSync(`./${randomName}`);
} else {
reply(sizetoo);
}
fs.unlinkSync(`./${randomName}`);
} catch (e) {
reply(N_FOUND)
l(e)
}
})

//---------------------------------------------------------------------------

cmd({
  pattern: "ytdocv",
  use: '.ytdoc <yt url>',
  react: "üéß",
  desc: "Download yt song.",
  category: "download",
  filename: __filename
},

async(conn, mek, m,{from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
if (!ytreg(q)) return await  reply(urlneed)
let infoYt = await ytdl.getInfo(q);
if (infoYt.videoDetails.lengthSeconds >= videotime) {
  reply(sizetoo);
  return;
}
let titleYt = infoYt.videoDetails.title;
let randomName = getRandom(".mp4");
const stream = ytdl(q, {
      filter: (info) => info.itag == 22 || info.itag == 18,
  })
  .pipe(fs.createWriteStream(`./${randomName}`));
await new Promise((resolve, reject) => {
  stream.on("error", reject);
  stream.on("finish", resolve);
});

let stats = fs.statSync(`./${randomName}`);
let fileSizeInBytes = stats.size;
let fileSizeInMegabytes = fileSizeInBytes / (1024 * 1024);
if (fileSizeInMegabytes <= config.MAX_SIZE) {
  let senda =  await conn.sendMessage(from, { document: fs.readFileSync(`./${randomName}`), mimetype: 'document/mp4', fileName: titleYt + '.mp4',caption: config.FOOTER  }, { quoted: mek })
  await conn.sendMessage(from, { react: { text: 'üéº', key: senda.key }})
return fs.unlinkSync(`./${randomName}`);
} else {
reply(sizetoo);
}
fs.unlinkSync(`./${randomName}`);
} catch (e) {
reply(N_FOUND)
l(e)
}
})

//---------------------------------------------------------------------------

cmd({
    pattern: "ytinfo",
    use: '.yt lelena',
    react: "üìΩÔ∏è",
    desc: descyt,
    category: "download",
    filename: __filename

},

async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
if (!q) return await reply(imgmsg)
if(isUrl(q) && !ytreg(q)) return await reply(imgmsg)
if(isUrl(q) && q.includes('/shorts')){let dat = `‚îå‚îÄ‚îÄ‚îÄ[üßö Ôº±ÔºµÔº•Ôº•ÔºÆ -Ôº©Ôº∫ÔºµÔº≠Ôº© - Ôº≠Ôº§ üßö]

  *SELECT TYPE*`
const buttons = []
const buttonMessage = {
    caption: dat,
    footer: config.FOOTER,
    buttons: buttons,
    headerType: 1
}
return await conn.buttonMessage(from, buttonMessage, mek)}
let yts = require("yt-search")
let search = await yts(q)
let anu = search.videos[0]
const cap = `‚îå‚îÄ‚îÄ‚îÄ[üßö Ôº±ÔºµÔº•Ôº•ÔºÆ -Ôº©Ôº∫ÔºµÔº≠Ôº© - Ôº≠Ôº§ üßö]

   *YT DOWNLOADER*

‚ïèüéÄ *Title:* ${anu.title}
‚¶Å
‚ïèüåê *Duration:* ${anu.timestamp}
‚¶Å
‚ïèüëÄ *Viewers:* ${anu.views}
‚¶Å
‚ïè‚¨ÜÔ∏è *Uploaded:* ${anu.ago}
‚¶Å
‚ïèüëΩ *Author:* ${anu.author.name}
‚¶Å
‚ïèüì° *Url* : ${anu.url}`
    
const buttons = []
const buttonMessage = {
    image: {url: anu.thumbnail},
    caption: cap,
    footer: config.FOOTER,
    buttons: buttons,
    headerType: 4
}
await conn.buttonMessage(from, buttonMessage)
} catch (e) {
  reply(N_FOUND)
  l(e)
}
})
